# PCB & Context Switching

# PCB

운영 체제에서 프로세스에 대한 정보를 저장하는 자료 구조. PCB 안에는 한 프로세스의 정보가 담긴다. 따라서, PCB는 각각의 프로세스마다 생성된다.

![Untitled](PCB%20&%20Context%20Switching%2087176c58e4be433b80d57f3b9097c831/Untitled.png)

## PCB에 담긴 정보

1. 프로세스 식별자(Process ID) : 각 프로세스마다 고유한 식별자가 할당되며, PCB에는 해당 프로세스의 ID가 저장된다.
2. 프로세스 상태 정보 : PCB는 프로세스의 상태 정보를 저장한다. 예를 들어, 프로세스가 실행 / 대기 / 중단 상태인지에 관련한 정보를 포함한다.
3. 프로그램 카운터(Program Counter) : 프로그램 카운터는 다음에 실행할 명령의 주소를 저장한다.
4. 레지스터 정보 : 프로세스가 사용하는 레지스터의 값과 상태 정보를 저장한다.
5. 프로세스 우선순위 : PCB는 프로세스가 현재 사용 중인 자원, 예를 들어 메모리나 입출력 장치 등을 추적하기 위한 정보를 저장ㅎ나다.
6. 입출력 상태 정보 : 프로세스가 대기 중인 입출력 작업에 대한 정보를 저장한다.
7. 계정 정보 : 프로세스가 사용한 CPU 시간, 입출력 시간 등과 같은 계정 정보를 저장한다.

이 정보들은 운영 체제마다 다를 수 있다.

## PCB의 주요 역할

1. 프로세스 관리 : 운영 체제는 각각의 프로세스를 관리하면서, PCB에 저장된 정보를 사용하여 프로세스 간 전환(Context Switching)을 수행한다.
2. 자원 할당 및 추적 : PCB는 프로세스가 현재 사용 중인 자원, 예를 들어 메모리나 입출력 장치 등을 추적하기 위한 정보를 저장한다. 이를 통해 운영 체제는 프로세스가 필요로 하는 자원을 할당하고, 자원 사용 중에 발생하는 문제를 해결하는 데 사용된다.
3. 스케줄링 : PCB는 프로세스의 우선순위를 저장한다. 이 정보는 스케줄링 알고리즘에서 프로세스의 우선순위를 결정하는 데에 사용된다. 따라서 PCB는 운영 체제가 스케줄링을 수행할 때, 어떤 프로세스를 결정하는 데 중요한 역할을 수행한다.

## PCB의 관리 방법

PCB는 Linked list 방식으로 관리된다.

> Linked list는 데이터 구조의 한 형태로, 여러 개의 노드(Node)가 연결된 구조이다. 각각의 노드는 데이터와 다음 노드의 주소를 저장하는 포인터로 구성되어 있다.
> 

PCB는 각각의 프로세스마다 생성되기 때문에, PCB가 생성될 때마다 PCB List HEAD에 PCB가 붙는다. 각각의 PCB는 다음 PCB의 주소를 가리키는 포인터를 갖는다. 이러한 방식을 통해 모든 PCB는 한 Linked list 안에 저장되고, 이 linked list는 운영 체제가 프로세스 간 전환을 수행할 때 다음 실행할 프로세스를 찾는 데에 사용된다.

또한, Linked list를 사용하면 새로운 프로세스를 생성하거나 종료할 때, 해당 PCB를 쉽게 추가, 제거, 업데이트 할 수 있다. 즉, 프로세스가 생성되면 PCB가 생성되고, 완료되면 제거된다.

이렇게 수행 중인 프로세스를 변경할 때, CPU의 레지스터 정보가 변경되는 것을 `Context Switching` 이라고 한다.

# Context Switching

운영 체제에서 프로세스 간 전환을 수행하는 작업. CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에서 읽어 레지스터에 적재하는 과정을 말한다.

## Context Switching을 하는 이유

컴퓨터에서는 여러 개의 프로세스가 동시에 실행될 수 있는 데에 반해, CPU는 한 번에 하나의 프로세스만 실행할 수 있다. 따라서, CPU가 실행 중인 프로세스를 다른 프로세스로 전환하는 작업을 수행해야 하고, 이 때 발생하는 작업이 Context Switching이다.

## Context Switching이 발생하는 상황

1. 프로세스 간 전환 : CPU가 실행 중인 프로세스를 다른 프로세스로 전환하는 작업을 수행할 때
2. 인터럽트 처리 : 하드웨어 또는 소프트웨어 인터럽트가 바라생할 때, CPU는 현재 실행 중인 프로세스를 일시 중단하고 인터럽트를 처리하는 데 필요한 작업을 수행한다. 이 때 인터럽드 처리 작업이 완료되면 CPU는 이전에 실행 중이었던 프로세스를 다시 실행하고, 이러한 과정 또한 Context Switching에 해당한다.
3. CPU 사용 허가시간이 모두 소모되었을 때 : 운영 체제가 해당 프로세스를 일시 중단하고 다른 프로세스를 실행해야 하므로 Context Switching이 수행된다.
4. 입출력을 위해 대기해야 하는 경우 : 입출력 작업은 일반적으로 느리기 때문에 CPU는 입출력 작업이 완료될 때까지 다른 프로세스를 실행할 수 있다. 이 때 운영 체제는 입출력 작업을 완료한 뒤 해당 프로세스를 재개하고 Context Switching을 수행한다.

## Context Switching의 OverHead

Context Switching은 CPU를 이전 프로세스에서 다음 프로세스로 전환하기 위해 추가적인 작업을 수행해야 하고, 이 때문에 오버헤드(Overhead : 과부하)가 발생한다.

앞서 입출력을 위해 대기해야 하는 경우와 같이, 프로세스를 수행하다가 대기 상태로 전환시키는 경우에 CPU를 계속해서 수행시키기 위해 다른 프로세스를 실행시키고 Context Switching하는 등 OverHead를 감수해야 하는 상황이 있다.

OverHead가 발생 가능한 다양한 상황은 아래와 같다.

1. 레지스터 값 저장 및 복원 : Context Switching을 수행할 때, 현재 실행 중인 프로세스의 레지스터 값(프로세스 상태 정보)을 저장하고, 다음 실행할 프로세스의 레지스터 값으로 복원해야 한다. 이 작업은 매우 빠르게 수행되지만 프로세스의 레지스터 값이 많으면 저장 및 복원 작업에 OverHead가 발생할 수 있다.
2. 메모리 관리 : Context Switching을 수행할 때 현재 실행 중인 프로세스의 메로리를 해제하고, 다음 실행할 프로세스의 메모리를 할당해야 한다. 이 때 작업할 메모리의 크기와 사용자의 활동량에 따라 OverHead가 발생할 수 있다.
3. 스케줄링 : 스케줄링 알고리즘의 복잡성과 프로세스의 수에 따라 OverHead가 발생할 수 있다.
4. 입출력 작업 : Context Switching을 수행할 때, 현재 실행 중인 프로세스가 입출력 작업을 수행 중인 경우, 해당 작업을 중단하고, 다른 프로세스를 실행해야 한다. 이 경우, 입출력 작업이 완료될 때까지 기다려야 하므로 오버헤드가 발생할 수 있다.

즉, 사용자에게 빠르게 일처리를 제공해주기 위해 OverHead를 감수하여 CPU를 효율적으로 운영한다. 