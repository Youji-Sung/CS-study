# Index(인덱스)



## 인덱스(index)란?

인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다.

책의 맨 앞 또는 맨 뒤에 추가되어 있는 색인과 같다. 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕는다.

![img](Index(%EC%9D%B8%EB%8D%B1%EC%8A%A4).assets/img.png)

인덱스를 활용하면 데이터를 조회하는 SELECT 외에도 UPDATE나 DELETE의 성능이 함께 향상된다. UPDATE나 DELETE와 같은 연산을 할 때 해당 대상의 조회가 함께 이루어지기 때문이다.

만일 Index를 사용하지 않은 컬럼을 조회해야 하는 상황이라면 Full Scan(전체를 비교하여 탐색)을 수행해야 한다.



## 인덱스(index)의 관리

DBMS는 index를 항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다. 따라서 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 아래와 같은 연산을 추가적으로 해주어야 하며 그에 따른 오버헤드가 발생하게 된다.

- INSERT : 새로운 데이터에 대한 인덱스를 추가함
- DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행함
- UPDATE : 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가함



## 인덱스(index)의 장점과 단점

### 장점

- 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
- 전반적인 시스템의 부하를 줄일 수 있다.

### 단점

- 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
- 인덱스를 관리하기 위해 추가 작업이 필요하다.
- 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.
- Index 생성시, .mdb 파일 크기가 증가한다.
- **한 페이지를 동시에 수정할 수 있는 병행성**이 줄어든다.
- 인덱스 된 Field에서 Data를 업데이트하거나, **Record를 추가 또는 삭제시 성능이 떨어진다.**
- 데이터 변경 작업이 자주 일어나는 경우, **Index를 재작성**해야 하므로 성능에 영향을 미친다.

> 만일 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 일어날 수 있다.



## 상황 분석

### 인덱스를 사용하면 좋은 경우

- Where 절에서 자주 사용되는 Column
- 외래키가 사용되는 Column
- Join에 자주 사용되는 Column

### 인덱스 사용을 피해야 하는 경우

- Data 중복도가 높은 Column
- DML이 자주 일어나는 Column



## DML이 일어났을 때의 상황

> DML 이란? 
>
> 데이터 조작어(DML : Data Manipulation Language) : SELECT, INSERT, UPDATE, DELETE와 같은 데이터를 조회하거나 검색하기 위한 명령어 또는 데이터베이스의 테이블에 들어 있는 데이터에 변형을 가하는 종류의 명령어를 말한다.

- ##### INSERT

  기존 Block에 여유가 없을 때, 새로운 Data가 입력된다.

  → 새로운 Block을 할당 받은 후, Key를 옮기는 작업을 수행한다.

  → Index split 작업 동안, 해당 Block의 Key 값에 대해서 DML이 블로킹 된다. (대기 이벤트 발생)

- ##### DELETE

  <Table과 Index 상황 비교>

  Table에서 data가 delete 되는 경우 : Data가 지워지고, 다른 Data가 그 공간을 사용 가능하다.

  Index에서 Data가 delete 되는 경우 : Data가 지워지지 않고, 사용 안 됨 표시만 해둔다.

  → **Table의 Data 수와 Index의 Data 수가 다를 수 있음**

- ##### UPDATE

  Table에서 update가 발생하면 → Index는 Update 할 수 없다.

  Index에서는 **Delete가 발생한 후, 새로운 작업의 Insert 작업** / 2배의 작업이 소요되어 힘들다.



## 인덱스(Index)의 자료구조

인덱스를 구현하기 위해서 가장 대표적으로 사용되는 자료구조는 해시 테이블과 B + Tree이다.

### 해시 테이블(Hash Table)

해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용하다. 해시 테이블은 Key값을 이용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조이다.

![img](Index(%EC%9D%B8%EB%8D%B1%EC%8A%A4).assets/img-16732715839573.png)

#### 특징

- 시간복잡도 O(1)로 매우 빠른 검색을 지원한다.
- DB인덱스에서 해시 테이블이 사용되는 경우는 제한적
  - 원인 : 등호(=) 연산에만 특화되었기 때문
  - 값이 조금이라도 달라지면 완전히 다른 값을 생성한다.
  - 따라서 부등호 연산이 자주 사용되는 데이터베이스 검색을 위해서는 적합하지 않다.

### B + Tree

B + Tree는 DB 인덱스를 위해 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다. B-Tree와 다른 특징은 아래와 같다.

- 리프노드(데이터노드)만 인덱스와 함께 데이터(Value)를 가지고 있고, 나머지 노드(인덱스노드)들은 데이터를 위한 인덱스(Key)만을 갖는다.
- 리프노드들은 LinkedList로 연결되어 있다.
- 데이터 노드 크기는 인덱스 노드의 크기와 같지 않아도 된다.

데이터베이스의 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생될 수 있으므로 B-Tree의 리프노드들을 LinkedList로 연결하여 순차검색을 용이하게 하는 등 B-Tree를 인덱스에 맞게 최적화하였다.

![img](Index(%EC%9D%B8%EB%8D%B1%EC%8A%A4).assets/img-16732717960016.png)

